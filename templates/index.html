<html>
    <head> <title>CSCI 5609 Final Project</title>

        <!-- bootstrap -->
        <script src="https://code.jquery.com/jquery-3.2.1.js"></script>
        <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

        <!-- d3 -->
        <script src="https://d3js.org/d3.v4.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="jumbotron">
                <h1>
                    Stack Overflow Tag Visualization
                </h1>
            </div>
            <form id='tagForm'>
            <div class="form-group row">
                <label for="tag" class="col-2 col-form-label">Enter Tag</label>
                <input class="form-control" type="text" value="JavaScript" id="tag">
            </div>
            <div class="form-group row">
                <input type="submit" style="display:none">
            </div>
            </form>
        </div>

        <div class="svg-container"></div>

    <div class="container">
    <ul class="list-group" id="vis-tag-list">
        <li class="list-group-item list-group-item-success">Tags</li>
    </ul>
    </div>

    </body>
<script>

$("#tagForm").submit( (e) => {
    e.preventDefault();
    const tag = $('#tag').val()
    getData(tag);
});

// add a d3 graph to the body of the webpage.
// The graph should show tags vs time for any tag I choose.
// It should also show results for groups of tags.

const jumbotronDimensions = document.querySelector('.jumbotron').getBoundingClientRect();

const width = 850;
const height = 350;

const MARGIN = {
    top: 100,
    right: 50,
    bottom: 60,
    left: (jumbotronDimensions.left + jumbotronDimensions.right - width) / 2
};

const chart = d3.select("div.svg-container")
    .append("div")
    .append("svg")
    .attr("width", width + MARGIN.left + MARGIN.right)
    .attr("height", height + MARGIN.top + MARGIN.bottom);

// Add another graphic onto same svg. must be called after createChart()
function addLayer(){
    const layer =  chart.append("g")
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`);
    return layer;
}

/*
Question: do we want to display the data on the same axis?
I say yes because google trends will display the data in that way.
The axis should be scaled to the highest value of the highest query.

Store each search term in in list.
When we add to the list, draw the line graph again, rescaling if the data is more than what we need.

1. Track array of queries with data
2. Draw graph with customized color based on the query
3. Resize graph (when max of all data increases )
4. Add widget to remove queries
*/

// Another issue is the time range over which to collect the data.
// The data could come from any time range, and we probably want to restrict ourselves to, like,
// the past 6 months.

const START_DATE = '2008-08-01';
const END_DATE = '2008-09-01';

class StackOverflowChart {

    constructor(){
        this.queries = [];
        this.color = -1;
        this.maxQueriesSingleDay = 0;
        this.yScale = null;
        this.dateStart = new Date('3000-01-01');  // positive inifinity  
        this.dateEnd =  new Date(0);  // negative infinity
    }

    nextColor(){
        this.color = (this.color + 1) % 10;
        return d3.schemeCategory10[this.color];
    }

    addQuery(tag, data){
        // remove the graphs. Each time a graph is added, redraw the entire chart to adjust for scaling issues.
        this.queries.push({ tag, data, color: this.nextColor() });

        if(data.length > 0){
            this.maxQueriesSingleDay = Math.max(this.maxQueriesSingleDay, d3.max(data, d=>d[1]));
            this.dateStart = new Date(Math.min(this.dateStart, d3.min(data, d=>d[0])));
            this.dateEnd = new Date(Math.max(this.dateEnd, d3.max(data, d=>d[0])));
        }

        this.addButton(tag);
        this.repaint();
     }


    addButton(tag){

        const div = $('<div/>', {
            class: 'list-group-item',
            text:  " " + tag,
        }).prepend($('<span/>', {
            class: "glyphicon glyphicon-trash",
            style: "color: red",
        }));
        div.data('tag', tag);
        div.click( (e) => {
            console.log(div.data('tag'));
            this.removeQuery(div.data('tag'));
            div.remove();
        });
        div.appendTo('#vis-tag-list');
    }

    removeQuery(tag){
        console.log("removing ", tag);
        console.log(tag === "javascript");
        const filtered = this.queries.filter(q => q.tag !== tag);
        this.queries = filtered;  // delete the svg
        this.repaint();
    }

    repaint(){
        chart.selectAll("*").remove(); 
        const xScale = d3.scaleTime()
        .domain([this.dateStart, this.dateEnd])
        .range([0, width]);

        const yScale = d3.scaleLinear()
        .domain([0, this.maxQueriesSingleDay])
        .range([height,0]);

        addGraph();
        drawAxes(xScale, yScale);
        this.queries.forEach(q => {
            drawLineGraph(q.tag, interpolateData(q.data, this.dateStart, this.dateEnd),
             q.color, xScale, yScale);
        });
    }

}


function drawLineGraph(tag, data, colr, xScale, yScale){
    const lineGenerator = d3.line()
        .x(d => xScale(d[0]))
        .y(d => yScale(d[1]));
    console.log(lineGenerator(data));
    addLayer()
        .append("path")
        .attr("d", lineGenerator(data))
        .style("stroke", colr)
        .style("stroke-width", 4)
        .style("fill", "none");
}

function drawAxes(xScale, yScale){
    const xAxis = d3.axisBottom().scale(xScale);
    const yAxis = d3.axisLeft().scale(yScale);
    addLayer()
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top + height})`)
        .call(xAxis);
    addLayer()
     .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`)
     .call(yAxis);
}

function addGraph(){
    addLayer().append("text")
        .attr("x", width / 2)
        .attr("y", 0)
        .attr("text-anchor", "middle")
        .style("font-size", "20px")
        .text("Queries over Time");
}


// convert data that may have few values to be 0
// between start date and stop date.
function interpolateData(data, startDate, stopDate){
    console.log(data, startDate, stopDate);
    const results = [];
    let i = 0;
    for(let d = new Date(startDate); d <= stopDate; d.setDate(d.getDate()+1)){
        if (i < data.length && data[i][0].getTime() === d.getTime()){
            const count =  data[i][1]];
            i++;
        } else {
            const count = 0;
        }
        results.push(new Date(d), count);
    }
    return results;
}

function getData(tag){
    $.getJSON('data', { 
        tag,
     }, (data) => {
        console.log(data);
        // convert strings to dates
        const data_with_dates = data.results.map( (d) => [  new Date(d[0]), d[1] ] );
        stackOverflowChart.addQuery(tag, data_with_dates);
    });
}

const stackOverflowChart = new StackOverflowChart();
getData('javascript');

    </script>

<style>
    ul.list-group:after {
      clear: both;
      display: block;
      content: "";
    }

    .list-group-item {
        float: left;
    }
</style>
</html>
