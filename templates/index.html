<html>
    <head> <title>CSCI 5609 Final Project</title>

        <!-- bootstrap -->
        <script src="https://code.jquery.com/jquery-3.2.1.js"></script>
        <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

        <!-- d3 -->
        <script src="https://d3js.org/d3.v4.js"></script>
        <script src="js/d3-tip/index.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="jumbotron">
                <h1>
                    Stack Overflow Tag Visualization
                </h1>
            </div>
        <div class="row">
        
            <form id='tagForm'>
            <div class="form-group row">
                <label for="tag" class="col-md-12 col-form-label">Enter Tag</label>
                <input class="form-control col-md-12" type="text" name="tagname" value="JavaScript" id="tag">

                <label for="start-date" class="col-md-12 col-form-label">Start Date</label>
                <input class="form-control col-md-12"  type="date" name="start-date" value="SET_BY_JS" id="start-date">

                <label for="end-date" class="col-md-12 col-form-label">End Date</label>
                <input class="form-control col-md-12"  type="date" name="end-date" value="SET_BY_JS" id="end-date">
            </div>
            <div class="form-group row">
                <input class="btn btn-primary" type="submit">
            </div>
            </form>
        </div>
        </div>

        <div class="svg-container"></div>

    <div class="container">
    <ul class="list-group" id="vis-tag-list">
        <li class="list-group-item list-group-item-success">Tags</li>
    </ul>
    </div>

    </body>
<script>


const START_DATE = '2017-01-01';
const END_DATE = '2017-03-13';

// add a d3 graph to the body of the webpage.
// The graph should show tags vs time for any tag I choose.
// It should also show results for groups of tags.

const jumbotronDimensions = $('.jumbotron')[0].getBoundingClientRect();

const WIDTH = 850;
const HEIGHT = 350;
const MARGIN = {
    top: 100,
    right: 50,
    bottom: 60,
    left: (jumbotronDimensions.left + jumbotronDimensions.right - WIDTH) / 2
};

const chart = d3.select("div.svg-container")
    .append("div")
    .append("svg")
    .attr("width", WIDTH + MARGIN.left + MARGIN.right)
    .attr("height", HEIGHT + MARGIN.top + MARGIN.bottom);

// Add another graphic onto same svg. must be called after createChart()
function addLayer(){
    const layer =  chart.append("g")
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`);
    return layer;
}

const tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html( (d) => {
  
  return `<span class="d3-tip-text">queries: <span class=d3-tip-text>${d[1]}`
});



class StackOverflowChart {

    constructor(){
        this.queries = [];
        this.color = -1;
        this.maxQueriesSingleDay = 0;
        this.yScale = null;
        this.dateStart = new Date(START_DATE);  // positive inifinity  
        this.dateEnd =  new Date(END_DATE);  // negative infinity
    }

    nextColor(){
        this.color = (this.color + 1) % 10;
        return d3.schemeCategory10[this.color];
    }

    addQuery(tag, data){
        // remove the graphs. Each time a graph is added, redraw the entire chart to adjust for scaling issues.
        const query = { tag, data, color: this.nextColor() };
        this.queries.push(query);

        if(data.length > 0){
            this.maxQueriesSingleDay = Math.max(this.maxQueriesSingleDay, d3.max(data, d=>d[1]));
            // We are allowing the user to select the start and end date, rather than the range of data.
            // this.dateStart = new Date(Math.min(this.dateStart, d3.min(data, d=>d[0])));
            // this.dateEnd = new Date(Math.max(this.dateEnd, d3.max(data, d=>d[0])));
        }

        this.addButton(query);
        this.repaint();
     }


    addButton(query){
        const div = $('<div/>', {
            class: 'list-group-item',
            text:  " " + query.tag,
            style: `border-color: ${query.color}; border-width: 4px`,
        }).prepend($('<span/>', {
            class: "glyphicon glyphicon-trash",
            style: `color: ${query.color}`
            //style: `color: red`,
        }));
        div.data('query', query);
        div.click( (e) => this.removeQuery(div.data('query')));
        div.appendTo('#vis-tag-list');
        query.div = div;
    }

    removeQuery(query){
        query.div.remove();
        this.queries = this.queries.filter(q => q !== query);
        this.repaint();
    }

    repaint(){
        chart.selectAll("*").remove(); 

        const xScale = d3.scaleTime()
        .domain([this.dateStart, this.dateEnd])
        .range([0, WIDTH]);

        const yScale = d3.scaleLinear()
        .domain([0, this.maxQueriesSingleDay])
        .range([HEIGHT,0]);

        addGraph();
        drawAxes(xScale, yScale);
        this.queries.forEach(q => {
            drawLineGraph(q.tag, q.data, //fillInZeroes(q.data, this.dateStart, this.dateEnd), broken somehow
             q.color, xScale, yScale);
        });
    }

}


function drawLineGraph(tag, data, colr, xScale, yScale){
    const lineGenerator = d3.line()
        .x(d => xScale(d[0]))
        .y(d => yScale(d[1]));
        
    addLayer()
        .append("path")
        .attr("d", lineGenerator(data))
        .style("stroke", colr)
        .style("stroke-width", 4)
        .style("fill", "none")
}

function drawAxes(xScale, yScale){
    const xAxis = d3.axisBottom().scale(xScale);
    const yAxis = d3.axisLeft().scale(yScale);
    addLayer()
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top + HEIGHT})`)
        .call(xAxis);
    addLayer()
     .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`)
     .call(yAxis);
}

function addGraph(){
    addLayer().append("text")
        .attr("x", WIDTH / 2)
        .attr("y", 0)
        .attr("text-anchor", "middle")
        .style("font-size", "20px")
        .text("Queries over Time");
}


// convert data that may have few values to be 0
// between start date and stop date.
function fillInZeroes(data, startDate, stopDate){
    console.log(data, startDate, stopDate);
    const results = [];
    let i = 0;
    let count;
    for(let d = new Date(startDate); d <= stopDate; d.setDate(d.getDate()+1)){
        if (i < data.length && data[i][0].getTime() === d.getTime()){
            count = data[i][1];
            i++;
        } else {
            count = 0;
        }
        results.push([new Date(d), count]);
    }
    return results;
}

function getData(tag, start, end){
    $.getJSON('data', { tag, start, end }, (data) => {
        console.log(data);
        // convert strings to dates
        const data_with_dates = data.results.map( (d) => [  new Date(d[0]), d[1] ] );
        stackOverflowChart.addQuery(tag, data_with_dates);
    });
}

let stackOverflowChart = new StackOverflowChart();
getData('JavaScript', START_DATE, END_DATE);

$("#tagForm").submit( (e) => {
    e.preventDefault();
    const tag = $('#tag').val();
    const start = $('#start-date').val();
    const end = $('#end-date').val();

    const startDate = new Date(start);
    const endDate = new Date(end);

    const oldTags = stackOverflowChart.queries.map(q => q.tag);

    if (stackOverflowChart.dateStart.getTime() !== startDate.getTime() 
        || stackOverflowChart.dateEnd.getTime() !== endDate.getTime()){
        console.log("getting new tag date ranges");
        stackOverflowChart.queries.forEach(q => stackOverflowChart.removeQuery(q));
        stackOverflowChart = new StackOverflowChart();
        oldTags.forEach(t => getData(t, start, end));
    }

    // chart needs values to set align of x-axis
    stackOverflowChart.dateStart = startDate;
    stackOverflowChart.dateEnd = endDate; 

    if (! oldTags.includes(tag)){ 
        getData(tag, start, end);
    }
});

$("#start-date").val(START_DATE);
$("#end-date").val(END_DATE);

</script>

<style>
    ul.list-group:after {
      clear: both;
      display: block;
      content: "";
    }

    .list-group-item {
        float: left;
    }
</style>
</html>
