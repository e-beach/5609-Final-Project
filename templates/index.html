<html>
    <head> <title>CSCI 5609 Final Project</title>

        <!-- bootstrap -->
        <script src="https://code.jquery.com/jquery-3.2.1.js"></script>
        <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

        <!-- d3 -->
        <script src="https://d3js.org/d3.v4.min.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="jumbotron">
                <h1>
                    Stack Overflow Tag Visualization
                </h1>
            </div>
            <form id='tagForm'>
            <div class="form-group row">
                <label for="tag" class="col-2 col-form-label">TagName</label>
                <input class="form-control" type="text" value="JavaScript" id="tag">
            </div>
            <div class="form-group row">
                <input type="submit" style="display:none">
            </div>
            </form>
        </div>
    </body>
<script>

$("#tagForm").submit( (e) => {
    e.preventDefault();
    const tag = $('#tag').val()
    getData(tag);
});

// add a d3 graph to the body of the webpage.
// The graph should show tags vs time for any tag I choose.
// It should also show results for groups of tags.

const jumbotronDimensions = document.querySelector('.jumbotron').getBoundingClientRect();

const width = 850;
const height = 350;

const MARGIN = {
    top: 100,
    right: 50,
    bottom: 60,
    left: (jumbotronDimensions.left + jumbotronDimensions.right - width) / 2
};

const chart = d3.select("body")
    .append("div")
    .append("svg")
    .attr("width", width + MARGIN.left + MARGIN.right)
    .attr("height", height + MARGIN.top + MARGIN.bottom);

// Add another graphic onto same svg. must be called after createChart()
function addLayer(){
    const layer =  chart.append("g")
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`);
    return layer;
}

/*
Question: do we want to display the data on the same axis?
I say yes because google trends will display the data in that way.
The axis should be scaled to the highest value of the highest query.

Store each search term in in list.
When we add to the list, draw the line graph again, rescaling if the data is more than what we need.

1. Track array of queries with data
2. Draw graph with customized color based on the query
3. Resize graph (when max of all data increases )
4. Add widget to remove queries
*/

// Another issue is the time range over which to collect the data.
// The data could come from any time range, and we probably want to restrict ourselves to, like,
// the past 6 months.

const START_DATE = '2008-08-01';
const END_DATE = '2008-09-01';

class StackOverflowChart {

    constructor(){
        this.queries = [];
        this.color = 0;
        this.maxQueriesSingleDay = 0;
        this.yScale = null;
        this.dateStart = new Date('3000-01-01');  // positive inifinity  
        this.dateEnd =  new Date(0);  // negative infinity
        addGraph();
    }

    nextColor(){
        this.colors = (this.colors + 1) % 10;
        return d3.schemeCategory10[this.colors];
    }

    addQuery(tag, data){
        // remove the graphs. Each time a graph is added, redraw the entire chart to adjust for scaling issues.
        chart.selectAll("*").remove(); 
        this.queries.push({
             tag, 
             data, 
             color: this.nextColor()
        });

        if(data.length > 0){
            this.maxQueriesSingleDay = Math.max(this.maxQueriesSingleDay, d3.max(data, d=>d[1]));
            this.dateStart = new Date(Math.min(this.dateStart, d3.min(data, d=>d[0])));
            this.dateEnd = new Date(Math.max(this.dateEnd, d3.max(data, d=>d[0])));
        }
     
        const xScale = d3.scaleTime()
        .domain([this.dateStart, this.dateEnd])
        .range([0, width]);

        const yScale = d3.scaleLinear()
        .domain([0, this.maxQueriesSingleDay])
        .range([height,0]);

        this.queries.forEach(q => {
            drawLineGraph(q.tag, q.data, q.color, xScale, yScale);
        });
     }

    removeQuery(tag){
        const filtered = this.queries.filter(q => q.tag !== tag);
        // delete the svg
        this.queries = filtered;
    }

}


function drawLineGraph(tag, data, colr, xScale, yScale){
    const xAxis = d3.axisBottom().scale(xScale);
    const yAxis = d3.axisLeft().scale(yScale);

    const lineGenerator = d3.line()
        .x(d => xScale(d[0]))
        .y(d => yScale(d[1]));

    addLayer()
        .append("path")
        .attr("d", lineGenerator(data))
        .style("stroke", colr)
        .style("stroke-width", 4)
        .style("fill", "none");
    addLayer()
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top + height})`)
        .call(xAxis);
    addLayer()
        .attr("transform", `translate(${MARGIN.left},${MARGIN.top})`)
        .call(yAxis);
}

function addGraph(){
    addLayer().append("text")
        .attr("x", width / 2)
        .attr("y", 0)
        .attr("text-anchor", "middle")
        .style("font-size", "20px")
        .text("Queries over Time");
}

function getData(tag){
    $.getJSON('data', { 
        tag,
     }, (data) => {
        console.log(data);
        // convert strings to dates
        const data_with_dates = data.results.map( (d) => [  new Date(d[0]), d[1] ] );
        stackOverflowChart.addQuery(tag, data_with_dates);
    });
}

const stackOverflowChart = new StackOverflowChart();
getData('javascript');

    </script>
</html>
